import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

const articlesPath = path.join(process.cwd(), 'content', 'articles');
const dataPath = path.join(process.cwd(), 'lib', 'data.ts');
const backupPath = path.join(process.cwd(), 'lib', 'data.ts.restore');

// Category mapping
const categoryMap: Record<string, string> = {
  'simptome': 'simptome',
  'boli': 'boli-cronice',
  'respiratorii': 'respiratorii',
  'preventie': 'preventie',
  'proceduri': 'proceduri',
  'nutritie': 'nutritie',
  'comportament': 'comportament',
  'ingrijire': 'ingrijire',
  'ghiduri': 'ghiduri'
};

async function fixData() {
  console.log('ðŸ“ Fixing lib/data.ts...\n');

  // Read backup to get breeds
  const backupContent = fs.readFileSync(backupPath, 'utf-8');

  // Extract breeds section from backup
  const breedsMatch = backupContent.match(/export const sampleBreeds: Breed\[\] = \[\s*\n([\s\S]*?)\n\];/);
  if (!breedsMatch) {
    console.error('âŒ Could not find breeds in backup');
    return;
  }

  const breedsContent = breedsMatch[0].replace('export const sampleBreeds: Breed[]', 'export const breeds: Breed[]');

  // Read all MDX files for articles
  const files = fs.readdirSync(articlesPath).filter(f => f.endsWith('.mdx'));
  console.log(`Found ${files.length} article files\n`);

  const articles = [];

  for (const file of files) {
    const filePath = path.join(articlesPath, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    const { data: frontmatter } = matter(content);

    const slug = file.replace('.mdx', '');
    const category = frontmatter.category || 'general';
    const subcategory = frontmatter.subcategory || '';

    // Determine image based on category/subcategory
    let imageName = 'general.jpg';
    if (subcategory && categoryMap[subcategory]) {
      imageName = `${categoryMap[subcategory]}.jpg`;
    } else if (categoryMap[category]) {
      imageName = `${categoryMap[category]}.jpg`;
    }

    articles.push({
      slug,
      title: frontmatter.title,
      description: frontmatter.description || frontmatter.excerpt || '',
      category: category,
      image: `/images/articles/${imageName}`,
      readingTime: frontmatter.readingTime || 5
    });
  }

  // Sort articles alphabetically
  articles.sort((a, b) => a.title.localeCompare(b.title, 'ro'));

  // Generate new data.ts content
  const newContent = `// Complete data for Pisicopedia.ro - All 30 breeds and articles
// Auto-generated by scripts/fix-data.ts
import { Breed, Article, Guide } from '@/types';

// All 30 cat breeds with images
${breedsContent}

// All articles
export const articles: Article[] = [
${articles.map(article => `  {
    slug: "${article.slug}",
    title: "${article.title.replace(/"/g, '\\"')}",
    description: "${article.description.replace(/"/g, '\\"')}",
    category: "${article.category}",
    image: "${article.image}",
    readingTime: ${article.readingTime}
  }`).join(',\n')}
];

// Guides
export const guides: Guide[] = [
  {
    slug: "cum-sa-alegi-pisica-potrivita",
    title: "Cum sÄƒ alegi pisica potrivitÄƒ pentru tine",
    description: "Ghid complet pentru alegerea rasei de pisicÄƒ potrivite stilului tÄƒu de viaÈ›Äƒ",
    category: "ghid-cumparare",
    image: "/images/guides/alegere-pisica.jpg",
    readingTime: 10
  },
  {
    slug: "pregatirea-casei-pentru-pisica",
    title: "PregÄƒtirea casei pentru noua pisicÄƒ",
    description: "Tot ce trebuie sÄƒ È™tii pentru a-È›i pregÄƒti casa pentru sosirea unei pisici",
    category: "ghid-ingrijire",
    image: "/images/guides/pregatire-casa.jpg",
    readingTime: 8
  }
];

// Helper functions
export const sampleBreeds = breeds;
export const sampleArticles = articles;

export function getAllBreeds() {
  return breeds;
}

export function getBreedBySlug(slug: string) {
  return breeds.find(breed => breed.slug === slug);
}

export function getTopBreeds(count: number = 6) {
  return breeds.slice(0, count);
}

export function getAllArticles() {
  return articles;
}

export function getArticleBySlug(slug: string) {
  return articles.find(article => article.slug === slug);
}

export function getLatestArticles(count: number = 6) {
  return articles.slice(0, count);
}

export function getArticlesByCategory(category: string) {
  return articles.filter(article => article.category === category);
}

export function getAllGuides() {
  return guides;
}

export function getTopGuides(count: number = 3) {
  return guides.slice(0, count);
}`;

  // Backup current file and write new content
  fs.copyFileSync(dataPath, `${dataPath}.backup-${Date.now()}`);
  fs.writeFileSync(dataPath, newContent);

  console.log(`âœ… Fixed lib/data.ts with ${articles.length} articles and all breeds`);
}

fixData().catch(console.error);